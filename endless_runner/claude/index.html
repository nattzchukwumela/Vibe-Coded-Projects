<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Slinger Runner</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1e);
        }

        #gameCanvas {
            display: block;
            image-rendering: crisp-edges;
        }

        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ff6666);
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            display: none;
            z-index: 20;
        }

        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.9);
        }

        .restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .restart-btn:hover {
            transform: scale(1.1);
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
    </style>
</head>

<body>
    <div class="game-ui">
        <div class="score">Score: <span id="scoreValue">0</span></div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
    </div>

    <div class="instructions">
        <div>SPACE/UP - Jump</div>
        <div>Hold SPACE near wall - Stick to Wall</div>
        <div>X - Shoot Laser</div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER</h2>
        <div style="font-size: 24px; margin-bottom: 20px;">Final Score: <span id="finalScore">0</span></div>
        <button class="restart-btn" onclick="restartGame()">RESTART</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const GROUND_HEIGHT = 100;
        const GROUND_Y = () => canvas.height - GROUND_HEIGHT;

        // Game variables
        let gameRunning = true;
        let score = 0;
        let gameSpeed = 5;
        let frameCount = 0;
        let lastPlatformX = 0;
        let lastWallX = 0;

        // Player object
        const player = {
            x: 100,
            y: canvas.height - 200,
            width: 40,
            height: 60,
            velocityY: 0,
            velocityX: 0,
            jumping: false,
            onGround: false,
            stickingToWall: false,
            health: 100,
            maxHealth: 100,
            color: '#ff4444',
            webColor: '#ffffff'
        };

        // Laser array
        const lasers = [];

        // Laser class
        class Laser {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 4;
                this.speed = 15;
                this.color = '#00ffff';
                this.particles = [];

                for (let i = 0; i < 3; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1,
                        life: 1
                    });
                }
            }

            update() {
                this.x += this.speed;

                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                });

                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;

                const gradient = ctx.createLinearGradient(this.x - this.width, this.y, this.x + this.width, this.y);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.2)');

                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, this.y - this.height / 2, this.width, this.height);

                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(p.x, p.y, 3, 3);
                });

                ctx.restore();
            }
        }

        // Platform arrays - separate ground from floating platforms
        const groundSegments = [];
        const floatingPlatforms = [];
        const walls = [];

        // Platform class
        class Platform {
            constructor(x, y, width, height, type = 'ground') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'ground', 'floating', 'wall'
                this.color = type === 'wall' ? '#444466' : (type === 'floating' ? '#557799' : '#666688');
            }

            update() {
                this.x -= gameSpeed;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Add depth effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(this.x, this.y + this.height - 5, this.width, 5);

                if (this.type === 'wall') {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < this.height; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + i);
                        ctx.lineTo(this.x + this.width, this.y + i);
                        ctx.stroke();
                    }
                }

                if (this.type === 'floating') {
                    // Add highlight to floating platforms
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(this.x, this.y, this.width, 3);
                }
            }
        }

        // Enemy array
        const enemies = [];

        // Enemy class
        class Enemy {
            constructor(x, y, type = 'ground') {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.type = type;
                this.health = type === 'flying' ? 1 : 2;
                this.baseY = y;
                this.color = type === 'flying' ? '#ff8800' : '#8800ff';
                this.hitFlash = 0;
            }

            update() {
                this.x -= gameSpeed;

                if (this.type === 'flying') {
                    this.y = this.baseY + Math.sin(Date.now() * 0.003) * 30;
                }

                if (this.hitFlash > 0) {
                    this.hitFlash--;
                }
            }

            takeDamage() {
                this.health--;
                this.hitFlash = 10;
                if (this.health <= 0) {
                    score += this.type === 'flying' ? 200 : 100;
                    return true;
                }
                return false;
            }

            draw() {
                ctx.save();

                if (this.hitFlash > 0) {
                    ctx.fillStyle = '#ffffff';
                } else {
                    ctx.fillStyle = this.color;
                }

                if (this.type === 'flying') {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x + this.width, this.y + this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                } else {
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    ctx.fillStyle = '#ff0000';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i * 15 + 5, this.y);
                        ctx.lineTo(this.x + i * 15 + 10, this.y - 10);
                        ctx.lineTo(this.x + i * 15 + 15, this.y);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        // Initialize ground
        function initializeGround() {
            // Create continuous ground
            for (let x = 0; x < canvas.width + 500; x += 300) {
                groundSegments.push(new Platform(x, GROUND_Y(), 300, GROUND_HEIGHT, 'ground'));
            }
            lastPlatformX = canvas.width;
        }

        // Generate ground segments
        function generateGround() {
            const lastGround = groundSegments[groundSegments.length - 1];
            if (lastGround && lastGround.x + lastGround.width < canvas.width + 300) {
                const newX = lastGround.x + lastGround.width;
                groundSegments.push(new Platform(newX, GROUND_Y(), 300, GROUND_HEIGHT, 'ground'));
            }
        }

        // Generate floating platforms
        function generateFloatingPlatform() {
            // Only generate if there's enough space since last platform
            if (lastPlatformX < canvas.width - 200) {
                if (Math.random() < 0.02) { // 2% chance per frame
                    const minY = GROUND_Y() - 350;
                    const maxY = GROUND_Y() - 150;
                    const y = minY + Math.random() * (maxY - minY);
                    const width = 100 + Math.random() * 100;

                    floatingPlatforms.push(new Platform(canvas.width + 50, y, width, 20, 'floating'));
                    lastPlatformX = canvas.width + 50;
                }
            }
        }

        // Generate walls
        function generateWall() {
            // Only generate if there's enough space since last wall
            if (lastWallX < canvas.width - 400) {
                if (Math.random() < 0.008) { // 0.8% chance per frame
                    const height = 150 + Math.random() * 150;
                    const y = GROUND_Y() - height;

                    walls.push(new Platform(canvas.width + 50, y, 30, height, 'wall'));
                    lastWallX = canvas.width + 50;
                }
            }
        }

        // Generate enemies
        function generateEnemy() {
            if (Math.random() < 0.01 && enemies.length < 4) {
                const type = Math.random() < 0.4 ? 'flying' : 'ground';
                let y;

                if (type === 'flying') {
                    y = GROUND_Y() - 200 - Math.random() * 150;
                } else {
                    y = GROUND_Y() - 40; // Place on ground
                }

                enemies.push(new Enemy(canvas.width + 50, y, type));
            }
        }

        // Handle input
        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            keys[e.code] = true;

            if (e.key === ' ' || e.key === 'ArrowUp' || e.code === 'Space') {
                e.preventDefault();
                if (player.onGround) {
                    player.velocityY = -18;
                    player.jumping = true;
                    player.onGround = false;
                } else if (player.stickingToWall) {
                    player.velocityY = -16;
                    player.velocityX = -8;
                    player.stickingToWall = false;
                    player.jumping = true;
                }
            }

            if (e.key === 'x' || e.key === 'X') {
                shootLaser();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            keys[e.code] = false;
        });

        // Shoot laser
        function shootLaser() {
            if (gameRunning && lasers.length < 5) {
                lasers.push(new Laser(player.x + player.width, player.y + player.height / 2));
            }
        }

        // Check collision
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }

        // Get all platforms
        function getAllPlatforms() {
            return [...groundSegments, ...floatingPlatforms, ...walls];
        }

        // Update player
        function updatePlayer() {
            // Apply gravity if not sticking to wall
            if (!player.stickingToWall) {
                player.velocityY += 0.8;
                player.x += player.velocityX;
                player.velocityX *= 0.9;
            } else {
                // Slowly slide down wall
                player.velocityY = 1.5;
            }

            // Update position
            player.y += player.velocityY;

            // Reset flags
            player.onGround = false;
            let wasSticking = player.stickingToWall;
            player.stickingToWall = false;

            // Check ground collisions
            for (let ground of groundSegments) {
                if (checkCollision(player, ground)) {
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= ground.y + 10) {
                        player.y = ground.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            }

            // Check floating platform collisions
            for (let platform of floatingPlatforms) {
                if (checkCollision(player, platform)) {
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y + 10) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            }

            // Check wall collisions
            for (let wall of walls) {
                if (checkCollision(player, wall)) {
                    // Check if player is in the air and holding space near wall
                    if (!player.onGround && (keys[' '] || keys['Space'])) {
                        player.stickingToWall = true;
                        player.x = wall.x - player.width;
                        player.velocityY = 0;
                        player.velocityX = 0;
                    } else if (player.velocityY > 0 && player.y + player.height - player.velocityY <= wall.y + 10) {
                        // Landing on top of wall
                        player.y = wall.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    } else if (!player.stickingToWall) {
                        // Push player back from wall
                        player.x = wall.x - player.width;
                    }
                }
            }

            // Release from wall if space is released
            if (wasSticking && !(keys[' '] || keys['Space'])) {
                player.stickingToWall = false;
            }

            // Keep player in bounds horizontally
            if (player.x < 50) {
                player.x = 50;
                player.velocityX = 0;
            }

            if (player.x > canvas.width / 2) {
                player.x = canvas.width / 2;
            }

            // Check if player fell off screen
            if (player.y > canvas.height + 100) {
                gameOver();
            }
        }

        // Draw player
        function drawPlayer() {
            ctx.save();

            // Draw player body
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw mask pattern
            ctx.fillStyle = '#cc0000';
            ctx.fillRect(player.x + 5, player.y + 5, player.width - 10, 25);

            // Draw eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(player.x + 12, player.y + 15, 6, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(player.x + 28, player.y + 15, 6, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Draw web effect when sticking to wall
            if (player.stickingToWall) {
                ctx.strokeStyle = player.webColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;

                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(player.x + player.width, player.y + 5 + i * 12);
                    ctx.quadraticCurveTo(
                        player.x + player.width + 20,
                        player.y + 5 + i * 12 + Math.sin(Date.now() * 0.01 + i) * 3,
                        player.x + player.width + 35,
                        player.y + 5 + i * 12
                    );
                    ctx.stroke();
                }
            }

            // Draw jump trail
            if (player.jumping && !player.onGround && !player.stickingToWall) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ff6666';
                for (let i = 1; i <= 3; i++) {
                    ctx.globalAlpha = 0.3 - i * 0.08;
                    ctx.fillRect(
                        player.x - i * 5,
                        player.y + player.height - 10 + i * 10,
                        player.width,
                        player.height * 0.5
                    );
                }
            }

            ctx.restore();
        }

        // Clean up off-screen objects
        function cleanupObjects() {
            // Remove off-screen ground segments
            for (let i = groundSegments.length - 1; i >= 0; i--) {
                if (groundSegments[i].x + groundSegments[i].width < -100) {
                    groundSegments.splice(i, 1);
                }
            }

            // Remove off-screen floating platforms
            for (let i = floatingPlatforms.length - 1; i >= 0; i--) {
                if (floatingPlatforms[i].x + floatingPlatforms[i].width < -100) {
                    floatingPlatforms.splice(i, 1);
                }
            }

            // Remove off-screen walls
            for (let i = walls.length - 1; i >= 0; i--) {
                if (walls[i].x + walls[i].width < -100) {
                    walls.splice(i, 1);
                }
            }

            // Remove off-screen enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (enemies[i].x + enemies[i].width < -100) {
                    enemies.splice(i, 1);
                }
            }

            // Remove off-screen lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                if (lasers[i].x > canvas.width + 50) {
                    lasers.splice(i, 1);
                }
            }
        }

        // Update game
        function updateGame() {
            if (!gameRunning) return;

            frameCount++;

            // Increase difficulty over time
            if (frameCount % 1000 === 0) {
                gameSpeed = Math.min(gameSpeed + 0.3, 12);
            }

            // Update score
            score += 1;
            document.getElementById('scoreValue').textContent = Math.floor(score / 10);

            // Update player
            updatePlayer();

            // Generate platforms
            generateGround();
            generateFloatingPlatform();
            generateWall();
            generateEnemy();

            // Update all platforms
            groundSegments.forEach(g => g.update());
            floatingPlatforms.forEach(p => p.update());
            walls.forEach(w => w.update());

            // Update tracking variables
            lastPlatformX -= gameSpeed;
            lastWallX -= gameSpeed;

            // Update enemies
            enemies.forEach(enemy => enemy.update());

            // Check enemy collisions with player
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (checkCollision(player, enemies[i])) {
                    player.health -= 20;
                    enemies.splice(i, 1);
                    updateHealthBar();

                    // Visual feedback
                    player.velocityX = -5;

                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }

            // Update lasers
            lasers.forEach(laser => laser.update());

            // Check laser collisions with enemies
            for (let i = lasers.length - 1; i >= 0; i--) {
                let laserHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(lasers[i], enemies[j])) {
                        if (enemies[j].takeDamage()) {
                            enemies.splice(j, 1);
                        }
                        laserHit = true;
                        break;
                    }
                }
                if (laserHit) {
                    lasers.splice(i, 1);
                }
            }

            // Cleanup off-screen objects
            cleanupObjects();
        }

        // Draw background
        function drawBackground() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73 + frameCount * 0.1) % canvas.width;
                const y = (i * 37) % (canvas.height / 2);
                ctx.globalAlpha = 0.3 + (i % 3) * 0.2;
                ctx.fillRect(x, y, 1 + (i % 2), 1 + (i % 2));
            }

            ctx.globalAlpha = 1;

            // Draw distant city silhouette (parallax layer 1 - slow)
            ctx.fillStyle = '#0f0f2a';
            for (let i = 0; i < 15; i++) {
                const x = (i * 200 - frameCount * 0.2) % (canvas.width + 200) - 200;
                const height = 150 + (i * 67) % 250;
                ctx.fillRect(x, canvas.height - GROUND_HEIGHT - height, 180, height);
            }

            // Draw closer city silhouette (parallax layer 2 - medium)
            ctx.fillStyle = '#1a1a3a';
            for (let i = 0; i < 12; i++) {
                const x = (i * 180 - frameCount * 0.5) % (canvas.width + 180) - 180;
                const height = 100 + (i * 47) % 200;
                ctx.fillRect(x, canvas.height - GROUND_HEIGHT - height, 150, height);
            }
        }

        // Update health bar
        function updateHealthBar() {
            const healthPercent = Math.max(0, player.health / player.maxHealth * 100);
            document.getElementById('healthFill').style.width = healthPercent + '%';
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = Math.floor(score / 10);
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            gameRunning = true;
            score = 0;
            gameSpeed = 5;
            frameCount = 0;
            lastPlatformX = 0;
            lastWallX = 0;

            player.x = 100;
            player.y = GROUND_Y() - 100;
            player.velocityY = 0;
            player.velocityX = 0;
            player.health = player.maxHealth;
            player.onGround = false;
            player.stickingToWall = false;
            player.jumping = false;

            groundSegments.length = 0;
            floatingPlatforms.length = 0;
            walls.length = 0;
            enemies.length = 0;
            lasers.length = 0;

            initializeGround();
            updateHealthBar();

            document.getElementById('gameOver').style.display = 'none';
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();

            // Draw all platforms
            groundSegments.forEach(g => g.draw());
            floatingPlatforms.forEach(p => p.draw());
            walls.forEach(w => w.draw());

            // Draw enemies
            enemies.forEach(enemy => enemy.draw());

            // Draw lasers
            lasers.forEach(laser => laser.draw());

            // Draw player
            drawPlayer();

            // Update game state
            updateGame();

            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        initializeGround();
        gameLoop();

        // Make restart function global
        window.restartGame = restartGame;
    </script>
</body>

</html>